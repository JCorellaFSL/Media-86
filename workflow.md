# Video Integration Workflow

This document outlines the proposed plan and technical considerations for integrating video playback and management into the Media-86 application.

## 1. Core Objectives

- **Playback**: Users should be able to open and play common video formats (e.g., MP4, MKV, WEBM) within the main application window.
- **Discovery**: The application should be able to scan directories and identify video files, listing them alongside images.
- **Basic Controls**: Standard video controls must be available (Play/Pause, volume, timeline scrubbing).

## 2. Proposed Technical Implementation

### Backend (Rust / Tauri)

- **Video Processing Library**: Integrate a robust, cross-platform media framework. The most suitable candidate is **GStreamer**.
  - **Why GStreamer?**: It is an extremely powerful, open-source multimedia framework that is mature and widely used. It handles a vast array of codecs and formats automatically and has good support for Rust.
  - **Alternative**: `ffmpeg`, while powerful, is more complex to integrate directly into a Rust application for playback purposes.
- **New Tauri Commands**:
  - `get_video_files`: A new command to specifically scan for and return a list of video files from a directory.
  - `get_video_metadata`: A command to extract metadata like duration, resolution, and codecs from a video file.
  - `generate_thumbnail`: A crucial command to create a thumbnail image from a video file for display in the sidebar. This prevents the performance cost of loading entire video files for a simple preview.

### Frontend (React)

- **UI Updates**:
  - **Video Player**: Replace the `<img>` tag with a `<video>` tag when a video file is selected.
  - **Video Icon**: Display a distinct icon (e.g., a film strip) next to video files in the sidebar.
  - **Thumbnails**: The sidebar will display the thumbnails generated by the backend instead of attempting to show a live preview of the video.
- **State Management**:
  - The main file list will become an array of objects, each with a `type` property (`'image'` or `'video'`) to allow for conditional rendering.
  - Add state for video-specific information like playback status, duration, and current time.

## 3. Step-by-Step Development Plan

1.  **Backend Setup**:
    - Add the `gstreamer` crate and its related dependencies to `Cargo.toml`.
    - Implement the `get_video_files` and `generate_thumbnail` commands in `src-tauri/src/lib.rs`.
2.  **Frontend Logic**:
    - Modify the file-opening logic to differentiate between image and video files.
    - Update the sidebar to display video files with their generated thumbnails.
3.  **Video Player Implementation**:
    - Create a dedicated `VideoPlayer` React component that wraps the `<video>` element.
    - Implement the basic play/pause, volume, and timeline controls.
4.  **Integration**:
    - Connect the frontend controls to the `<video>` element's API.
    - Ensure smooth transitions between viewing images and videos.

## 4. Potential Challenges

- **GStreamer Installation**: GStreamer can be complex to set up on all target platforms (especially Windows), and this may add steps to the build process.
- **Performance**: Generating thumbnails for a large number of videos could be slow. We may need to implement a caching system or a background processing queue.
- **Codec Support**: While GStreamer is comprehensive, certain proprietary codecs may require users to install additional plugins on their system. 